\section{并发集合}
\subsection{List: CopyOnWriteArrayList}

并发列表只有一个 CopyOnWriteList，顾名思义，它是一个线程安全的 ArrayList，对其进行的操作都是在底层的一个复制的数组(快照)上进行的，使用了写时复制策略。

\begin{Java}
// Java17
public class CopyOnWriteArrayList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable {
    final transient Object lock = new Object();
    private transient volatile Object[] array;
}
\end{Java}

在 Java8 中使用的时 ReentrantLock(一种可重入独占锁) 实现锁机制，而 Java17 中使用的是 synchronized 锁住普通的 Object 对象 lock。这两种机制实现的效果类似，没有很大差别，正如注释所述:

\begin{center}
\textit{We have a mild preference for builtin monitors over ReentrantLock when either will do.}
\end{center}

CopyOnWriteArrayList 在涉及到修改数组的操作时会使用 synchronized(lock) 的方式上锁，这里的修改是指任何非只读操作，包括增加，替换，排序，删除...

我们看一下 add 操作:

\begin{Java}
public boolean add(E e) {
    synchronized (lock) {
        Object[] es = getArray();
        int len = es.length;
        es = Arrays.copyOf(es, len + 1);
        es[len] = e;
        setArray(es);
        return true;
    }
}
\end{Java}

最关键的是第一步操作，每次调用该操作都是尝试获取 lock 锁，如果有其他线程占用了 lock 锁(不仅是 add 操作)，线程会被阻塞。

此外，我们会发现，CopyOnWriteArrayList 没有扩容机制，他在 add 时会直接申请一个新的空间，这非常费时间,set 也类似。

\begin{Java}
public E set(int index, E element) {
    synchronized (lock) {
        Object[] es = getArray();
        E oldValue = elementAt(es, index);
        if (oldValue != element) {
            es = es.clone();
            es[index] = element;
        }
        setArray(es);
        return oldValue;
    }
}
\end{Java}

多线程操作可迭代对象存在弱一致性问题，这个问题是指返回迭代器后，其他线程对 list 的增删改对迭代器是不可见的。下面看看 CopyOnWriteArrayList 是如何解决这个问题的:

\begin{Java}
public Iterator<E> iterator() {
    return new COWIterator<E>(getArray(), 0);
}

static final class COWIterator<E> implements ListIterator<E> {
    // 数组快照
    private final Object[] snapshot;
    // 数组下标游标，用于迭代获取元素
    private int cursor;

    COWIterator(Object[] es, int initialCursor) {
        cursor = initialCursor;
        snapshot = es;
    }

    public boolean hasNext() {
        return cursor < snapshot.length;
    }

    @SuppressWarnings("unchecked")
    public E next() {
        if (! hasNext())
            throw new NoSuchElementException();
        return (E) snapshot[cursor++];
    }

    public int nextIndex() {
        return cursor;
    }

    // Not supported. Always throws UnsupportedOperationException.
    public void remove() {
        throw new UnsupportedOperationException();
    }
    public void set(E e) {
        throw new UnsupportedOperationException();
    }
    public void add(E e) {
        throw new UnsupportedOperationException();
    }
}
\end{Java}

获取 CopyOnWriteArrayList 的迭代器对象时，实际上会返回一个 COWIterator 对象，该对象通过 snapshot 保存了当前 list 的内容。注意 snapshot 本质上只是个指针。

如果在遍历期间，其他线程对该 list 进行了修改，那么 snapshot 就是快照了，因为增删改后list里面的数组被新数组替换了，这时候老数组被snapshot引用。这也说明获取迭代器后，使用该迭代器元素时，其他线程对该list进行的增删改不可见，因为它们操作的是两个不同的数组，这就是弱一致性。

这也间接说明，在调用 System 的 copyOf 后，原数组不会被立刻清除，如果没有引用才会被 GC。此外，COWIterator 对象不允许使用修改操作。

总而言之，CopyOnWriteArrayList使用写时复制的策略来保证list的一致性，而获取—修改—写入三步操作并不是原子性的，所以在增删改的过程中都使用了独占锁，来保证在某个时间只有一个线程能对list数组进行修改。

另外CopyOnWriteArrayList提供了弱一致性的迭代器，从而保证在获取迭代器后，其他线程对list的修改是不可见的，迭代器遍历的数组是一个快照。

\fbox{
    \parbox{0.87\textwidth}{
        \begin{notice}
            一般情况下，不要使用 CopyOnWriteArrayList，它只有一个优点: 保证线程安全。但是写时复制策略会照成很大的时间和空间开销，他没有 ArrayList 的扩容机制，迭代器会保存快照，导致旧的数组空间无法被 GC。只有极少情况，需要保存快照且需要保证线程安全时才会用到它。
        \end{notice}
    }
}

