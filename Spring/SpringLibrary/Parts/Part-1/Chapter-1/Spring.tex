\section{Spring 常用注解}
\subsection{Spring Bean 基础注解}

这节的前四个个注解功能基本都是一样的，都是将类作为 bean 注入到 spring 容器中进行管理，只不过它们使用的场景不同。后几个注解是对前几个注解的修饰。

选择上，如果确定是 MVC 的哪一层，就选择对应的具体注解(@Controller, @Service, @Repository)标识，如果不确定，但又知道它是各组件，就用 @Component 标识。这四个注解除了可以明确层次关系，没有其他区别。

\subsubsection{@Component}

@Component 标注一个普通的组件类，通知 Spring 将类纳入到 Spring Bean 容器中并进行管理。默认定义的 bean 是单例的。可以通过 @Component(“beanName”) @Scope(“prototype”) 改变，下面同样。

\begin{Java}
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Indexed
public @interface Component {
    String value() default "";
}
\end{Java}

\subsubsection{@Controller}

对应 Spring MVC 控制层，主要用户接受用户 http 请求并调用 Service 层返回数据给前端页面。

\begin{Java}
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Controller {
    @AliasFor(annotation = Component.class)
    String value() default "";
}
\end{Java}

\subsubsection{@Service}

对应 Spring MVC 业务层。主要用于获取 pojo 层的的数据并进行业务处理，

\begin{Java}
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Service {
    @AliasFor(annotation = Component.class)
    String value() default "";
}
\end{Java}

\subsubsection{@Repository}

@Repository 对应持久层(pojo)。主要用于直接和数据库交互。

\begin{Java}
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Repository {
    @AliasFor(annotation = Component.class)
    String value() default "";
}
\end{Java}

\subsubsection{@Scope}

@Scope 注解用于指定 Bean 的作用范围，也即采用的设计模式。

\begin{Java}
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Scope {
    @AliasFor("scopeName")
	String value() default "";
	@AliasFor("value")
	String scopeName() default "";
    ScopedProxyMode proxyMode() default ScopedProxyMode.DEFAULT;
}
\end{Java}
一般的有两个选项，"singleton" 与 "prototype"，分别代表单例设计模式与原型设计模式。默认采用单例模式。

\subsubsection{@PostConstrucor 与 @PreDestroy}

顾名思义，这两个注解作用的生命周期分别是: 构造方法后和销毁前。对应了 Bean 生命周期的 init-method 和 destroy-method。

\begin{Java}
@Documented
@Retention (RUNTIME)
@Target(METHOD)
public @interface PostConstruct

@Documented
@Retention (RUNTIME)
@Target(METHOD)
public @interface PreDestroy

\end{Java}

\subsubsection{@Bean}

@Bean 主要用于将一个方法地返返回值注册为 Bean:

\begin{Java}
@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Bean
\end{Java}

为什么要这样设计呢，主要是为了管理外部的 Bean:

\begin{Java}
@Bean
public DataSource getDataSource() {
    DruidDataSource di = new DruidDataSource();
    ds.setDriverClassName("com.mysql.jdbc.Driver");
    ...
    return ds;
}
\end{Java}

同时，@Bean 也是自动装配的，如果有形参，容器会自动注入对应类型的形参。

\subsection{Spring Bean 配置注解}

\subsubsection{@Configuration}

声明当前类为配置类，相当于 xml 形式的 Spring 配置。

\begin{Java}
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Configuration {
    @AliasFor(annotation = Component.class)
    String value() default "";
    boolean proxyBeanMethods() default true;
}
\end{Java}

\subsubsection{@ComponentScan}

顾名思义，用来扫描 Component 并批量注册 Bean，默认情况下扫描当前包及子包的 Component，可以自定义扫描位置\footnote{延申文献: \url{https://zhuanlan.zhihu.com/p/520827986}}:

\begin{Java}
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Repeatable(ComponentScans.class)
public @interface ComponentScan {
    @AliasFor("basePackages")
    String[] value() default {};
    ......
}
\end{Java}

\subsubsection{@PropertySource}

@PropertySource 注解用于绑定 properties 文件:

\begin{Java}
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Repeatable(PropertySources.class)
public @interface PropertySource {
    String[] value();
    ......
}
\end{Java}

一般的 @PropertySource 作用在 Config 文件上\footnote{延申文献: \url{https://blog.csdn.net/tenghu8888/article/details/119791417}}。

\subsubsection{@Import}

@import 注解用于导入别的注解，当有多个 Config 时，一般在 Spring 的 Config 中导入其他配置文件。

\begin{Java}
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Import {
    Class<?>[] value();
}
\end{Java}

举个例子:

\begin{Java}
@Configuration
@Import
public class SpringConfig
\end{Java}

\subsection{Spring DI 注解}

前面 Spring 已经完成了 Bean 的标识与扫描，但这仅仅是将 Bean 装入了 IoC 容器，下面注解实现了 DI。

\subsubsection{@Autowired}

@Autowired 注解顾名思义，进行自动装配，是一个功能十分强大，实现比较复杂，有争议的注解。

\begin{Java}
@Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Autowired {
    boolean required() default true;
}    
\end{Java}

默认情况下，@Autowired 根据类型实现自动装配，构造方法注入和 setter 注入都可以实现。@Autowired 可以直接作用在属性上，而不直接使用 setter 方法注入，它将使用暴力反射的方式将对应的类型注入到属性中\footnote{延申文献: \url{https://blog.csdn.net/Weixiaohuai/article/details/123005140}}。注意，既然使用了暴力反射，就要提供 bean 的无参构造方法。

@Autowired 默认使用也推荐使用类型注入，但类型注入必然会带来问题: 同类型二义性，不知道用哪个。

\subsubsection{@Qualifier}

@Qualifier 用于按名称注入，他必须依赖于 @Autowired 注解。

\begin{Java}
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Qualifier {
    String value() default "";
}
\end{Java}

使用时，必须先给出 @Autowired 注解:

\begin{Java}
@Autowired
@Qualifier("bookDao")   // 对应某个 bean 名为 bookDao
private BookDao bookDao;
\end{Java}

当然这样有个问题，耦合度高！！！

\subsubsection{@Value}

注意这里是 Spring Framework 里的 @Value 不是 lombok 的 @Value。

@Autowired 有一个缺陷，他只能注入引用类型，注入基本类型\footnote{想念 Python}要依靠 @Value:

\begin{Java}
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Value {
    String value();
}
\end{Java}

@Value 一般用于注入 properties 文件的内容。需要结合 @PropertySource 注解使用。

\begin{Java}
@PropertySource("classpath:jdbc.properties")    // classpath: 可以不加
public class JdbcProperties {
    ......
}

@Repository
public class BookDao {
    @Value(${name})     // jdbc.properties 存在字段和 ${} 内容相同
    private String name;
}
\end{Java}

\newpage