\section{Spring 注解}
\subsection{Spring Bean 注解}

\subsubsection{@Configuration}

声明当前类为配置类，相当于 xml 形式的 Spring 配置。

\begin{Java}
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Configuration {
    @AliasFor(annotation = Component.class)
    String value() default "";
    boolean proxyBeanMethods() default true;
}
\end{Java}


\subsubsection{@Component}

@Component 标注一个普通的组件类，通知 Spring 将类纳入到 Spring Bean 容器中并进行管理。value不写默认就是类名首字母小写。

\begin{Java}
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Indexed
public @interface Component {
    String value() default "";
}
\end{Java}

\subsubsection{@Controller}

对应 Spring MVC 控制层，主要用户接受用户 http 请求并调用 Service 层返回数据给前端页面。

\begin{Java}
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Controller {
    @AliasFor(annotation = Component.class)
    String value() default "";
}
\end{Java}

\subsection{SpringBoot 注解}
\subsubsection{@SpringBootApplication}

@SpringBootApplication 表明这是一个 Spring 引导应用程序，默认 SpringBoot 项目的启动类会被该注解修饰。

\begin{Java}
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = { 
    @Filter(type = FilterType.CUSTOM,classes = TypeExcludeFilter.class), 
    @Filter(type = FilterType.CUSTOM, classes =AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {
    // ... 此处省略源码
}
\end{Java}

可以看出，该注解是由三个注解组成，这里做简单说明，细节请查询相应的注解:
\begin{itemize}
    \item @ComponentScan: 自动扫描并加载符合条件的组件。
    \item @EnableAutoConfiguration: 借助@Import的支持，收集和注册特定场景相关的bean定义。
    \item @SpringBootConfiguration: 标注当前类是配置类，并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名。
\end{itemize}

参考文献:
\begin{itemize}
    \item CSDN: \url{https://blog.csdn.net/qq_28289405/article/details/81302498}
\end{itemize}

\subsection{Spring Web 注解}

\subsubsection{@RequestMapping}

作用: 将 Web 请求与请求处理类中的方法进行映射

\begin{Java}
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Mapping
public @interface RequestMapping {
    // 省略具体实现
}
\end{Java}

它有以下的六个配置属性:
\begin{itemize}
    \item value: 映射请求的 URL 或者别名。
    \item method: 兼容HTTP的方法名
    \item params: 根据HTTP参数的存在、缺省或值对请求进行过滤
    \item header: 根据HTTP Header的存在、缺省或值对请求进行过滤
    \item consume: 设定在HTTP请求正文中允许使用的媒体类型
    \item product: 在HTTP响应体中允许使用的媒体类型
\end{itemize}

在使用@RequestMapping之前，请求处理类还需要使用 @Controller 进行标记。

\begin{Java}
@Controller
@RequestMapping("/home")
public class HomeController {
    ......
}
\end{Java}

\paragraph*{@GetMapping}

用于于处理HTTP GET请求，并将请求映射到具体的处理方法中。具体来说，@GetMapping是一个组合注解，它相当于是@RequestMapping(method=RequestMethod.GET)的快捷方式。下面几个映射注解也类似。

\begin{Java}
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@RequestMapping(method = RequestMethod.GET)
public @interface GetMapping {
    // 省略具体实现
}
\end{Java}

给个例子，下面几个不给了:

\begin{Java}
@Controller
@RequestMapping("/home")
public class HomeController {
    @GetMapping("/users")
    public List<User> findAllUsers() {
        List<User> users = userService.findAll();
        return users;
    }
    ......
}
\end{Java}

\paragraph*{@PostMapping}

注解用于处理HTTP POST请求。

\begin{Java}
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@RequestMapping(method = RequestMethod.POST)
public @interface PostMapping {
    // 省略具体实现
}
\end{Java}

\paragraph*{@PutMapping}

注解用于处理HTTP PUT请求，

\begin{Java}
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@RequestMapping(method = RequestMethod.PUT)
public @interface PutMapping {
    // 省略具体实现
}
\end{Java}

\paragraph*{@DeleteMapping}

注解用于处理HTTP Delete请求，

\begin{Java}
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@RequestMapping(method = RequestMethod.DELETE)
public @interface DeleteMapping {
    // 省略具体实现
}
\end{Java}

\paragraph*{@PatchMapping}

注解用于处理HTTP PATCH请求，

\begin{Java}
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@RequestMapping(method = RequestMethod.DELETE)
public @interface DeleteMapping {
    // 省略具体实现
}
\end{Java}

\subsubsection{@ModelAttribute}

@ModelAttribute主要的作用是将数据添加到模型对象中，用于视图页面显示。@ModelAttribute注释的位置不同,和其他注解一起使用时有很多种用法。\footnote{参考文献: \url{https://blog.csdn.net/yue_xx/article/details/105740360}}

\begin{Java}
@Target({ElementType.PARAMETER, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ModelAttribute {
    @AliasFor("name")
    String value() default "";
    @AliasFor("value")
    String name() default "";
    boolean binding() default true;
}
\end{Java}

主要用途可分为注解在方法上和注解在参数上:
\begin{itemize}
    \item 用在方法上，@ModelAttribute 注解的方法会在 Controller 每个方法被执行前调用。根据返回值不同也有区分。
    \begin{itemize}
        \item void 方法: 一般会在方法的参数中使用 Model 参数，在方法体内将模型数据添加到模型对象中。
\begin{Java}
@ModelAttribute 
public void NoneReturn(@RequestParam String data, Model model) { 
    model.addAttribute("指定一个名称",data); 
}
\end{Java}
        \item 具体类型方法: 一般用@ModelAttribute的value属性指定model属性的名称。model属性对应的对象就是方法的返回值。不指定名称，则model属性名就会默认是返回类型的首字母小写。
\begin{Java}
@ModelAttribute(name = "tacoOrder")
public TacoOrder order() {
    return new TacoOrder();
}
\end{Java}
        \item @ModdelAttribute和@RequestMapping共同注解一个方法时: 此时方法的返回值并不是表示一个视图名称，而是model属性的值，此时的视图名称就是@RequestMapping中指定的访问路径的最后一层去掉扩展名。
\begin{Java}
@RequestMapping(value = "指定一个访问路径") 
@ModelAttribute("指定一个名称") 
public String Fix() { 
    return "猛虎蔷薇"; 
} 
\end{Java}
    \end{itemize}
    \item 标记在方法的参数上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用。
\end{itemize}

\subsubsection{@SessionAttributes}

若希望在多个请求之间共用数据，则可以在控制器类上标注一个 @SessionAttributes,配置需要在session中存放的数据范围，Spring MVC将存放在model中对应的数据暂存到 HttpSession 中。

\begin{Java}
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface SessionAttributes {
    @AliasFor("names")
    String[] value() default {};
    @AliasFor("value")
    String[] names() default {};
    Class<?>[] types() default {};
}
\end{Java}


\newpage